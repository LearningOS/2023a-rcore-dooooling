## 实验报告 - ch4

### 编程作业

#### 作业要求
- 引入虚存机制后，原来内核的 sys_get_time 和 sys_task_info 函数实现就无效了。重写这个函数，恢复其正常功能。
- 完成系统调用 mmap 和 munmap。 mmap为虚存映射，munmap 为取消虚存映射。

#### 实现过程
- sys_get_time 和 sys_task_info 函数失效的原因是传递进来的参数是虚拟地址内核无法直接访问，添加 **vaddr_to_paddr** 将虚拟地址转换成物理地址后在修改对应参数值即可。
- sys_get_time 的实现需要注意获取时间导致bug。
- 在 MemorySet 中添加 insert_framed_area_checked 用于检查映射的内存地址中是否包含已使用的地址并完成对应的地址映射，参考已有方法 **insert_framed_area**。在 MemorySet 添加 remove_framed_area 方法，检查对应地址是否已经映射并调用 PageTable 中的 nummap 方法完成对应地址的取消映射。
- 实现的过程参考并借用了本节实验的基础内容，需要对本节课程的知识熟练掌握。
---

### 简答作业
1. - sv39页表项从高到低为 ：
    - `[63:54]`:保留
    - `[53:10]`:物理页号
    - `[9:8]`:RSW: 预留给系统管理员使用
    - `[7]`:D(Dirty) 记录自从页表项上的这一位被清零之后，页表项的对应虚拟页表是否被修改过
    - `[6]`:A(Accessed): 处理器记录自从页表项上的这一位被清零之后，页表项的对应虚拟页面是否被访问过
    - `[5]`:G(Global): 全局映射，用于TLB
    - `[4]`:U(User):控制索引到这个页表项的对应虚拟页面是否在 CPU 处于 U 特权级的情况下是否被允许访问
    - `[3-1]`:R(Read)/W(Write)/X(eXecute) 分别控制索引到这个页表项的对应虚拟页面是否允许读/写/执行
    - `[0]`:V(Valid)：仅当位 V 为 1 时，页表项才是合法的
2. - 与 Page fault相关的异常有： Instruction Page Fault、Load Page Faul、Store Page Fault
- 缺页异常触发一个硬件中断，并在 scause 设置导致缺页中断的原因，stval 设置需要访问但是不在内存中的地址
- 减少task未正式启动占用的内存大小，同时避免大体积程序因为业务或相关逻辑仅执行少量代码就退出导致的无意义的内存申请。
- 大约占用十几M内存
- 在内存映射时仅设置页表，不分配实际物理页，当发生 page fault时在分配物理页。
- 将PTE中的valid标志位设置为无效
3. - 通过修改satp寄存器值切换页表
- 将PTE user标志位设置为无效
- 在内核态和用户态之间不用切换页表，中断调用等更简单。
- 双页在用户程序和内核切换时、用户程序之间切换时都需要更换页表，单页表仅需要在不同用户线程切换时更换页表。
---

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

无

2. 此外，我也参考了以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。
   我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。
   我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。